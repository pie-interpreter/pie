# Ebnf PHP grammar
#

#
# TOKENS
#

# ignored tokens (specified in PieLexer class)
T_COMMENT: "//([^\n])*\n";
T_DOC_COMMENT: "/\*\*([^\*]|\*[^/])*\*?\*/";
T_INLINE_COMMENT: "/\*([^\*]|\*[^/])*\*?\*/";
T_WHITESPACE: "\s";

# original PHP tokens
T_ARRAY_CAST: "\([ \t]*(array)[ \t]*\)";
T_BOOL_CAST: "\([ \t]*((bool)|(boolean))[ \t]*\)";
T_BOOLEAN_AND: "&&";
T_BOOLEAN_OR: "\|\|";
T_BREAK: "break";
T_CLOSE_TAG: "\?>";
T_CONTINUE: "continue";
T_CONSTANT_ENCAPSED_STRING: "(\"[^\"]*\")|('[^']*)'";
T_DEC: "--";
T_DO: "do";
T_DOUBLE_CAST: "\([ \t]*((float)|(double)|(real))[ \t]*\)";
T_ECHO: "echo";
T_ELSEIF: "elseif";
T_ELSE: "else";
T_FOR: "for";
T_FUNCTION: "function";
T_IF: "if";
T_INC: "\+\+";
T_INCLUDE: "include";
T_INCLUDE_ONCE: "include_once";
T_INT_CAST: "\([ \t]*((int)|(integer))[ \t]*\)";
T_INLINE_HTML: "\?><\?php";
T_LNUMBER: "(0|[1-9])[0-9]*";
T_LOGICAL_AND: "and";
T_LOGICAL_OR: "or";
T_LOGICAL_XOR: "xor";
T_UNSET_CAST: "\([ \t]*(unset)[ \t]*\)";
T_OBJECT_CAST: "\([ \t]*(object)[ \t]*\)";
T_OPEN_TAG: "<\?php";
T_RETURN: "return";
T_REQUIRE: "require";
T_REQUIRE_ONCE: "require_once";
T_STRING_CAST: "\([ \t]*(string)[ \t]*\)";
T_WHILE: "while";


# non-original PHP tokens, that are in most cases
# treated as simple strings in PHP parser

# misc
TRUE: "true";
FALSE: "false";
NULL: "null";
IDENTIFIER: "[a-z_][a-z0-9_]*";

# operations in decreasing order of priorities:
# ones, that executed first are first in the list
MULTITIVE_OPERATOR: "\*|/|%";
ADDITIVE_OPERATOR: "[+\.]";
MINUS_OPERATOR: "-";
COMPARE_OPERATOR: "(<=)|(>=)|<|>";
EQUALITY_OPERATOR: "(===)|(!==)|(==)|(!=)|(<>)";
TERNARY_OPERATOR_FIRST_PART: "\?";
TERNARY_OPERATOR_SECOND_PART: ":";
ASSIGN_OPERATOR: "(\+=)|(-=)|(\*=)|(/=)|(\.=)|(%=)|(=)";
LOGICAL_NOT_OPERATOR: "!";


#
# RULES
#

# TOP-LEVEL rules:
# - basically file is list of code and inline-html blocks
# - code is list of statements
# - statements can be finished or not finished
# - finished statements don't require a semicolon in the end of it
# - not finished statements do
#
# - finished statements divided in two groups: top level ones and other
#   top level are the ones, that can be found only in main part of the file:
#   statements like class or function declarations, the rest are control
#   structures like for, switch, while

file: >contents<;
contents: >content_block< >contents< | [EOF];
content_block: T_INLINE_HTML
             | >code<;
code: [T_OPEN_TAG] >top_level_statements_block<;

# top level list of statements include top level finished statements
top_level_statements_block: >tol_level_statement< >top_level_statements_block<
                          | >notfinished_statement< [";"]? [T_CLOSE_TAG]
                          | >top_level_finished_statement< [T_CLOSE_TAG]
                          | [";"] [T_CLOSE_TAG];

tol_level_statement: >notfinished_statement< [";"]
                   | >top_level_finished_statement<
                   | [";"];


# statements block, that can be found anywhere in the file
statements_block: >statement< >statements_block<
                | >statement<;
# basic common statement
statement: >notfinished_statement< [";"]
         | >finished_statement<
         | [";"];



# NOT FINISHED STATEMENTS
# not finished statement is something, that require a semicolon in the end of it
# e.g. all kinds of expressions, language constructs
notfinished_statement: expression
                     | >construct<;


# language constructs
construct: construct_echo
         | construct_include
         | construct_include_once
         | construct_require
         | construct_require_once
         | construct_return
         | construct_break
         | construct_continue;

construct_echo: [T_ECHO] >comma_seperated_expressions<
              | [T_ECHO] ["("] >expression< [")"];

construct_include: [T_INCLUDE] expression
                 | [T_INCLUDE] ["("] expression [")"];
construct_include_once: [T_INCLUDE_ONCE] expression
                      | [T_INCLUDE_ONCE] ["("] expression [")"];
construct_require: [T_REQUIRE] expression
                 | [T_REQUIRE] ["("] expression [")"];
construct_require_once: [T_REQUIRE_ONCE] expression
                      | [T_INCLUDE] ["("] expression [")"];

construct_return: [T_RETURN] expression?;

construct_break: [T_BREAK] ["("] T_LNUMBER [")"]
               | [T_BREAK] T_LNUMBER?;

construct_continue: [T_CONTINUE] ["("] T_LNUMBER [")"]
                  | [T_CONTINUE] T_LNUMBER?;


# expressions definition, based on priority of operators
# expression is anything, that returns a value
expression: <logical_xor_expression>;

# logical are "and", "or" and "xor" operations
logical_xor_expression: logical_or_expression [T_LOGICAL_XOR] >logical_xor_expression_inner<
                      | <logical_or_expression>;
logical_xor_expression_inner: logical_or_expression [T_LOGICAL_XOR] >logical_xor_expression_inner<
                            | logical_or_expression;

logical_or_expression: logical_and_expression [T_LOGICAL_OR] >logical_or_expression_inner<
                     | <logical_and_expression>;
logical_or_expression_inner: logical_and_expression [T_LOGICAL_OR] >logical_or_expression_inner<
                           | logical_and_expression;

logical_and_expression: assign_expression [T_LOGICAL_AND] >logical_and_expression_inner<
                      | <assign_expression>;
logical_and_expression_inner: assign_expression [T_LOGICAL_AND] >logical_and_expression_inner<
                            | assign_expression;

assign_expression: variable_expression ASSIGN_OPERATOR assign_expression
                 | <ternary_expression>;

ternary_expression: boolean_or_expression [TERNARY_OPERATOR_FIRST_PART] expression [TERNARY_OPERATOR_SECOND_PART] expression
                  | <boolean_or_expression>;

# boolean are "&&" and "||" operations
boolean_or_expression: boolean_and_expression [T_BOOLEAN_OR] >boolean_or_expression_inner<
                      | <boolean_and_expression>;
boolean_or_expression_inner: boolean_and_expression [T_BOOLEAN_OR] >boolean_or_expression_inner<
                            | boolean_and_expression;

boolean_and_expression: equality_expression [T_BOOLEAN_AND] >boolean_and_expression_inner<
                      | <equality_expression>;
boolean_and_expression_inner: equality_expression [T_BOOLEAN_AND] >boolean_and_expression_inner<
                            | equality_expression;

equality_expression: compare_expression EQUALITY_OPERATOR equality_expression
                   | <compare_expression>;

compare_expression: additive_expression COMPARE_OPERATOR compare_expression
                  | <additive_expression>;

additive_expression: MINUS_OPERATOR >additive_expression_inner<
                   | multitive_expression ADDITIVE_OPERATOR >additive_expression_inner<
                   | <multitive_expression>;
additive_expression_inner: multitive_expression ADDITIVE_OPERATOR >additive_expression_inner<
                         | multitive_expression;

multitive_expression: logical_not_expression MULTITIVE_OPERATOR >multitive_expression_inner<
                    | <logical_not_expression>;
multitive_expression_inner: logical_not_expression MULTITIVE_OPERATOR >multitive_expression_inner<
                          | logical_not_expression;

logical_not_expression: [LOGICAL_NOT_OPERATOR] logical_not_expression
                      | <incdeccast_expression>;

# increment/decrement and typecasting operations have same priority
incdeccast_expression: <incdec_expression>
                     | <cast_expression>;
incdec_expression: T_INC variable_identifier
                 | T_DEC variable_identifier
                 | variable_identifier T_INC
                 | variable_identifier T_DEC;
cast_expression: >cast_token< incdeccast_expression
               | <primary_expression>;
cast_token: T_ARRAY_CAST
          | T_BOOL_CAST
          | T_DOUBLE_CAST
          | T_INT_CAST
          | T_OBJECT_CAST
          | T_STRING_CAST
          | T_UNSET_CAST;

primary_expression: ["("] <expression> [")"]
                  | <function_call>
                  | <variable_expression>
                  | <constant_expression>;

variable_expression: <variable_identifier>;
variable_identifier: ["$"] IDENTIFIER;
constant_expression: <T_LNUMBER>
                   | <T_CONSTANT_ENCAPSED_STRING>
                   | <TRUE>
                   | <FALSE>
                   | <NULL>;

function_call: >function_call_identifier< >function_parameters<;
function_call_identifier: IDENTIFIER
                        | variable_expression;
function_parameters: ["("] function_parameters_list? [")"];
function_parameters_list: expression [","] >function_parameters_list<
                        | expression;


# expressions block, that can be found in for loop and other places
comma_seperated_expressions: expression [","] >comma_seperated_expressions<
                           | expression;



# TOP LEVEL FINISHED STATEMENTS
# finished statements are ones, that do not require semicolon in the end of it
# e.g for, while, function definition, class definitions
top_level_finished_statement: function_declaration
                            | >finished_statement<;


function_declaration: [T_FUNCTION] IDENTIFIER >function_arguments< ["{"] statements_block? ["}"];
function_arguments: ["("] function_arguments_list? [")"];
function_arguments_list: >function_argument< [","] >function_arguments_list<
                       | >function_argument<;
function_argument: function_argument_with_default_value
                 | variable_identifier;
function_argument_with_default_value: variable_identifier [ASSIGN_OPERATOR] >function_argument_default_value<;
function_argument_default_value: constant_expression;



# NORMAL FINISHED STATEMENTS
#
finished_statement: if
                  | while
                  | dowhile
                  | for;

if: [T_IF] ["("] expression [")"] >ifelse_body< >else_inner<?;
else_inner: [T_ELSE] ["{"] ["}"]
          | else
          | elseif;
else: [T_ELSE] >ifelse_body<;
elseif: [T_ELSEIF] ["("] expression [")"] >ifelse_body< >else_inner<?;
ifelse_body: ["{"] statements_block? ["}"]
           | >statement<;

while: [T_WHILE] ["("] expression [")"] >while_body<;
while_body: ["{"] statements_block? ["}"]
          | [";"];

dowhile: [T_DO] ["{"] statements_block? ["}"] [T_WHILE] ["("] expression [")"] [";"];

for: [T_FOR] ["("] for_init? [";"] for_condition? [";"] for_expression? [")"] >for_body<;
for_init: >comma_seperated_expressions<;
for_condition:  >comma_seperated_expressions<;
for_expression:  >comma_seperated_expressions<;
for_body: ["{"] statements_block? ["}"]
        | [";"];

